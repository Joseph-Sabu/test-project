<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Diagram</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        circle { fill: steelblue; }
        line { stroke: black; }
        text { font: 10px sans-serif; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
</head>
<body>
    <h1>Network Diagram Visualizer</h1>
    <br>
    <h3>Upload Excel file</h3>
    <p>To generate a diagram please upload an <b>xlsx</b> file with data in the following format: </p>
    <table border="1" style="border-collapse: collapse; border: 1px solid black;">
        <thead>
            <tr>
                <th>Name</th>
                <th>IP</th>
                <th>ConnectsTo</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Server1</td>
                <td>192.168.1.1</td>
                <td>Firewall1</td>
            </tr>
            <tr>
                <td>Server2</td>
                <td>192.168.2.1</td>
                <td>Server3, Firewall2</td>
            </tr>
            <tr>
                <td>Server3</td>
                <td>192.168.3.1</td>
                <td>Firewall3</td>
            </tr>
        </tbody>
    </table>
    
    <br>
    <form id="uploadForm" action="/upload" method="POST" enctype="multipart/form-data">
        <input type="file" name="file" accept=".xlsx" />
        <button type="submit">Generate Diagram</button>
    </form>

<br><br>
    <!-- form for adding new device to diagram -->
    <h3>Add new Device</h3>
    <form id="addDeviceForm">
        <label for="deviceName">Device Name</label>
        <input type="text" id="deviceName" name="deviceName" required>
        
        <label for="deviceType">Device Type</label>
        <select name="deviceType" id="deviceType">
            <option value="server">Server</option>
            <option value="firewall">Firewall</option>
        </select>
        
        <label for="ipAddress">IP Address</label>
        <input type="text" id="ipAddress" name="ipAddress" required>
        
        <label for="connectsTo">Connects To</label>
        <select id="connectsTo" name="connectsTo"></select>
        
        <button type="button" id="addDeviceButton">Add Device</button>
    </form>

    <button id="saveAsPdf">Save Diagram as PDF</button>

    <svg width="800" height="600"></svg>

    <script>
        const svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

            let nodes = [];
            let links = [];

        function drawDiagram({ nodes: initialNodes, links: initialLinks }) {
            nodes = initialNodes;
            links = initialLinks;

            // Update Connects To dropdown
            updateConnectsToDropdown();


        // Function to draw the network diagram
            svg.selectAll("*").remove();

            // Setting up the simulation with forces
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))  
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked)
                .on("end", () => {
                    // After simulation has stabilized, fixing the node positions
                    nodes.forEach(d => {
                        d.fx = d.x;
                        d.fy = d.y;
                    });
                });

            // Creating links
            const link = svg.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke-width", d => Math.sqrt(d.value));

            // Creating nodes
            const node = svg.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", 10)
                .attr("fill", "steelblue")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

    

            // Adding labels (node name and IP address) to the nodes
            const label = svg.append("g")
            .attr("class", "labels")
            .selectAll("g")
            .data(nodes)
            .enter().append("g");

            // Node Name
            label.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(d => d.id);

            // IP Address
            label.append("text")
            .attr("dx", 12)
            .attr("dy", "1.75em")
            .text(d => d.ip);

            // Defining the tick function for the simulation
            function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => {
                    d.x = Math.max(10, Math.min(width - 10, d.x));
                    return d.x;
                })
                .attr("cy", d => {
                    d.y = Math.max(10, Math.min(height - 10, d.y));
                    return d.y;
                });

            // Updating the position of both labels (name and IP address)
            label
                .attr("transform", d => `translate(${d.x},${d.y})`);
            }


            // Dragging functions for interactivity
            function dragstarted(event, d) {
                
                d3.select(this).raise().attr("stroke", "black");
            }

            function dragged(event, d) {
                // Constrain the x and y position of the node within the SVG boundaries
                d.fx = Math.max(10, Math.min(width - 10, event.x));
                d.fy = Math.max(10, Math.min(height - 10, event.y));
            
                // Updating the node's position in the visualization
                d3.select(this)
                    .attr("cx", d.fx)
                    .attr("cy", d.fy);
            
                // Updating the label's position along with the node
                label
                    .filter(l => l.id === d.id)
                    .attr("transform", `translate(${d.fx},${d.fy})`);
            
                // Updating the links dynamically while dragging
                svg.selectAll("line")
                    .filter(l => l.source.id === d.id || l.target.id === d.id)
                    .attr("x1", l => l.source.fx)
                    .attr("y1", l => l.source.fy)
                    .attr("x2", l => l.target.fx)
                    .attr("y2", l => l.target.fy);
            }

            function dragended(event, d) {
                // Keep the node fixed at the new position
                
                d3.select(this).attr("stroke", "#fff");
            }
        }

        // Handle the form submission
        document.getElementById('uploadForm').onsubmit = async function(event) {
            event.preventDefault();
            const formData = new FormData(this);
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                 // Draw the network diagram with received data
                drawDiagram(data);
            } else {
                console.error('Error uploading file:', response.statusText);
            }
        };

        //function to load connectsTo dropdownlist
        function updateConnectsToDropdown() {
            const connectsToDropdown = document.getElementById("connectsTo");
            connectsToDropdown.innerHTML = '';

            // Populate the dropdown with current node names
            nodes.forEach(node => {
                const option = document.createElement("option");
                option.value = node.id;
                option.text = node.id;
                connectsToDropdown.appendChild(option);
            });
        }

        // Handling the Add Device button click
        document.getElementById("addDeviceButton").onclick = function() {
            const deviceName = document.getElementById("deviceName").value;
            const deviceType = document.getElementById("deviceType").value;
            const ipAddress = document.getElementById("ipAddress").value;
            const connectsTo = document.getElementById("connectsTo").value;

            if (!deviceName || !ipAddress) {
                alert("Please fill in all fields for the device.");
                return;
            }

            // Add the new node and link to the diagram data
            const newNode = { id: deviceName, ip: ipAddress, type: deviceType };
            nodes.push(newNode);
            links.push({ source: deviceName, target: connectsTo, value: 10 });

            // Redraw the diagram with the new node and link
            drawDiagram({ nodes, links });

            // Reset the form fields
            document.getElementById("addDeviceForm").reset();
            updateConnectsToDropdown();
        };

        //save as pdf
        document.getElementById('saveAsPdf').addEventListener('click', async () => {
    const svgElement = document.querySelector('svg');
    const svgRect = svgElement.getBoundingClientRect();
    
    // Clone the SVG element for rendering
    const svgData = new XMLSerializer().serializeToString(svgElement);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to match the SVG dimensions
    canvas.width = svgRect.width;
    canvas.height = svgRect.height;

    // Use an image to render the SVG on canvas
    const img = new Image();
    img.onload = () => {
        ctx.drawImage(img, 0, 0);
        const pdf = new jspdf.jsPDF({
            orientation: svgRect.width > svgRect.height ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [svgRect.width, svgRect.height]
        });

        // Convert canvas to PNG and add it to the PDF
        const imgData = canvas.toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', 0, 0, svgRect.width, svgRect.height);

        // Save the PDF
        pdf.save('network-diagram.pdf');
    };

    img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);
});

    </script>

</body>
</html>
